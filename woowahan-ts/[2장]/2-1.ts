// 타입
// 1) 자료형으로서의 타입
// 컴퓨터 메모리 공간은 한정적 -> 값의 크기를 명시하면 컴퓨터가 값을 효율적이고 안전하게 저장
// --> 이를 위해 ECMAScript 표준을 따르는 7가지 데이터타입 정의
// undefined, null, boolean, string, symbol, Number(+ BigInt), Object
// 메모리 관점에서 데이터 타입은 프로그래밍 언어에서 일반적으로 타입으로 부르는 개념과 같다.

// 2) 집합으로서의 타입
// 프로그래밍에서 타입은 수학의 집합과 유사, 값이 가질 수 있는 유효한 범위의 집합을 의미
// 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지
// ex1)
const num: number = 123;
const str: string = 'abc';
const func = (n: number) => {};
func(str); // number타입 값만 할당할 수 있도록 제한
// --> func() 함수의 인자로 들어갈 수 있는 값을 number 타입의 집합으로 제한
// 즉, 타입이 함수의 매개변수에 대한 값의 범위를 제한

// 타입을 결정하는 시점에 따라 정적, 동적 타입으로 분류

// 정적 타입 시스템 -> 모든 변수의 타입이 컴파일타임에 결정
// 코드 수준에서 개발자가 타입을 명시. C, Java, TypeScript
// 컴파일타임에 타입 에러를 발견할 수 있어 프로그램의 안정성 보장

// 동적 타입 시스템 -> 변수의 타입이 런타임에 결정
// 개발자가 직접 타입 정의 X. Python, JavaScript
// 프로그램을 실행할 때 타입 에러가 발견
// 개발 과정에서 에러 없이 코드 작성 가능

// 런타임에서 타입을 예측할 수 없는 상황 예제 - JavaScript(동적 타입 언어)
const multiplyByThree = (number) => {
  return number * 3;
};
multiplyByThree(3); // 9
multiplyByThree('ffff'); // NaN

// 개발자가 의도적으로 타입 명시 or 변경하지 않아도 컴파일러나 엔진 등에 의해 런타임에 자동으로 변경되는 것
// --> 암묵적 타입 변환 (강타입, 약타입으로 분류)

// 강타입 - 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러에서 에러 발생
// 약타입 - 서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산 수행 후 값 도출

// ex 약타입) - JavaScript
console.log(1 + '2'); // 12
// --> 타입이 잘못 작성된 코드도 암묵적 타입 변환 수행 -> 예기치 못한 오류 발생 가능

// ex 강타입) - TypeScript
console.log(1 + '2'); // error

// 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합을 타입 시스템
// 명시적 타입 시스템 - 개발자가 직접 타입 명시
// 자동 타입 추론 시스템 - 컴파일러가 타입을 추론
// --> TypeScript는 두 가지 방식 모두 사용, 코드의 안정성과 가독성 향상

// 컴파일 방식
// 사람이 이해할 수 있는 방식으로 작성한 코드 ==> 컴퓨터가 이해할 수 있는 기계어로 변환
// TypeScript의 컴파일 결과물은 사람이 이해할 수 있는 방식인 JavaScript 파일
// 왜?
// TypeScript 탄생 이유는 컴파일타임에 런타임 에러를 사전에 잡아내기 위해
// 따라서, TypeScript를 컴파일하면 타입이 모두 제거된 JavaScript 소스만 남는다.
