# 5-1. 조건부 타입

- 조건부 타입을 사용해 조건에 따라 출력 타입을 다르게 도출할 수 있다.
- ts의 조건부 타입은 js의 삼항 연산자와 동일하게 `Condition ? A : B` 형태를 가지는데 `A`는 Condition이 `true`일 때 도출되는 타입이고, `B`는 `false`일 때 도출되는 타입이다.
- 이를 활용하면 **중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있기 때문에 더욱 정확한 타입 추론**을 할 수 있게 된다.
- `extends`,`infer`,`never` 활용

## 1) extends와 제네릭을 활용한 조건부 타입

- `extends`는 타입을 확장할 때와 타입을 조건부로 설정할 때 사용되며, 제네릭 타입에서는 한정자 역할로도 사용된다.

> T extends U ? X : Y

- 조건부 타입에서 `extends`를 사용할 때는 삼항 연산자와 함께 쓴다.
- 타입 T를 U에 할당할 수 있으면 X 타입, 아니면 Y 타입으로 결정됨을 의미한다.

```ts
// 1)
interface Bank {
  finacialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  finacialCode: string;
  companyName: string;
  name: string;
  appCardType?: string;
}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```

- 제네릭 매개변수에 "card"가 들어오면 `Card` 타입, 그 외의 값이 들어오면 `Account`타입으로 결정

## 2) 조건부 타입을 사용하지 않았을 때의 문제점

```ts
interface PayMethodBaseFromRes {
  finacialCode: string;
  name: string;
}

interface Bank extends PayMethodBaseFromRes {
  fullName: string;
}

interface Card extends PayMethodBaseFromRes {
  appCardType?: string;
}

type PayMethodInterface = {
  companyName: string;
};
type PayMethodInfo<T extends Bank | Card> = T & PayMethodInterface;
```

- `PayMethodBaseFromRes` : 서버에서 받아오는 결제 수단 기본 타입으로 은행과 카드에 모두 해당
- `Bank, Card` : 은행과 카드 각각에 맞는 결제 수단 타입. 결제 수단 기본타입인 `PayMethodFromRes`를 상속
- `PayMethodInterface` : 프론트에서 관리하는 결제 수단 UI 관련 데이터
- `PayMethodInfo<T extends Bank | Card>`
  - 최종적인 은행, 카드 결제 수단 타입. 프론트 UI 데이터 타입과 제네릭으로 받아오는 Bank 또는 Card 를 합성
  - `extends`를 제네릭에서 **한정자**로 사용하여 Bank 또는 Card를 포함하지 않는 타입은 제네릭으로 넘기지 못하게 방어
  - `BankPayMethodInfo = PayMethodInterface & Bank` 처럼 카드와 은행의 타입을 만들 수 있지만, **제네릭을 통해 중복된 코드를 제거**한다.

```

```
